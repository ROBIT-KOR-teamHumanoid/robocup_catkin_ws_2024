// Generated by gencpp from file msg_generate/eom_msg.msg
// DO NOT EDIT!


#ifndef MSG_GENERATE_MESSAGE_EOM_MSG_H
#define MSG_GENERATE_MESSAGE_EOM_MSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace msg_generate
{
template <class ContainerAllocator>
struct eom_msg_
{
  typedef eom_msg_<ContainerAllocator> Type;

  eom_msg_()
    : IK_Flag(false)
    , Entire_Time(0.0)
    , Frequency(0.0)
    , Double_Ratio(0.0)
    , Single_Ratio(0.0)
    , Default_X_Right(0.0)
    , Default_X_Left(0.0)
    , Default_Y_Right(0.0)
    , Default_Y_Left(0.0)
    , Default_Z_Right(0.0)
    , Default_Z_Left(0.0)
    , Offset_10_Motor(0.0)
    , Offset_11_Motor(0.0)
    , Offset_12_Motor(0.0)
    , Offset_13_Motor(0.0)
    , Offset_14_Motor(0.0)
    , Offset_15_Motor(0.0)
    , Offset_16_Motor(0.0)
    , Offset_17_Motor(0.0)
    , Offset_18_Motor(0.0)
    , Offset_19_Motor(0.0)
    , Offset_20_Motor(0.0)
    , Offset_21_Motor(0.0)
    , Swing_Right_Leg(0.0)
    , Swing_Left_Leg(0.0)
    , Swing_Right_Shoulder(0.0)
    , Swing_Left_Shoulder(0.0)
    , Rise_Right_Leg(0.0)
    , Rise_Left_Leg(0.0)
    , Start_Entire_Time(0.0)
    , Start_Swing(0.0)
    , Start_Rise(0.0)
    , End_Entire_Time(0.0)
    , End_Swing(0.0)
    , End_Rise(0.0)
    , Test_X(0.0)
    , Test_Side(0.0)
    , Test_Yaw(0.0)
    , Tuning_X(0.0)
    , Tuning_Side(0.0)
    , Tuning_Yaw(0.0)
    , Balance_Value_0(0.0)
    , Balance_Value_1(0.0)
    , Balance_Value_2(0.0)
    , Balance_Value_3(0.0)
    , Balance_Pitch_GP(0.0)
    , Balance_Pitch_GI(0.0)
    , Balance_Pitch_GD(0.0)
    , Balance_Pitch_ELIMIT(0.0)
    , Balance_Pitch_OLIMIT(0.0)
    , Balance_Pitch_Neg_Target(0.0)
    , Balance_Pitch_Pos_Target(0.0)
    , Balance_Roll_GP(0.0)
    , Balance_Roll_GI(0.0)
    , Balance_Roll_GD(0.0)
    , Balance_Roll_ELIMIT(0.0)
    , Balance_Roll_OLIMIT(0.0)
    , Balance_Roll_Neg_Target(0.0)
    , Balance_Roll_Pos_Target(0.0)
    , Balance_Angle_Pitch_GP(0.0)
    , Balance_Angle_Pitch_GI(0.0)
    , Balance_Angle_Pitch_GD(0.0)
    , Balance_Angle_Pitch_ELIMIT(0.0)
    , Balance_Angle_Pitch_OLIMIT(0.0)
    , Balance_Angle_Pitch_Neg_Target(0.0)
    , Balance_Angle_Pitch_Pos_Target(0.0)
    , Balance_Pitch_Flag(false)
    , Balance_Angle_Pitch_Flag(false)
    , Balance_Roll_Flag(false)
    , Balance_Time_Flag(0.0)  {
    }
  eom_msg_(const ContainerAllocator& _alloc)
    : IK_Flag(false)
    , Entire_Time(0.0)
    , Frequency(0.0)
    , Double_Ratio(0.0)
    , Single_Ratio(0.0)
    , Default_X_Right(0.0)
    , Default_X_Left(0.0)
    , Default_Y_Right(0.0)
    , Default_Y_Left(0.0)
    , Default_Z_Right(0.0)
    , Default_Z_Left(0.0)
    , Offset_10_Motor(0.0)
    , Offset_11_Motor(0.0)
    , Offset_12_Motor(0.0)
    , Offset_13_Motor(0.0)
    , Offset_14_Motor(0.0)
    , Offset_15_Motor(0.0)
    , Offset_16_Motor(0.0)
    , Offset_17_Motor(0.0)
    , Offset_18_Motor(0.0)
    , Offset_19_Motor(0.0)
    , Offset_20_Motor(0.0)
    , Offset_21_Motor(0.0)
    , Swing_Right_Leg(0.0)
    , Swing_Left_Leg(0.0)
    , Swing_Right_Shoulder(0.0)
    , Swing_Left_Shoulder(0.0)
    , Rise_Right_Leg(0.0)
    , Rise_Left_Leg(0.0)
    , Start_Entire_Time(0.0)
    , Start_Swing(0.0)
    , Start_Rise(0.0)
    , End_Entire_Time(0.0)
    , End_Swing(0.0)
    , End_Rise(0.0)
    , Test_X(0.0)
    , Test_Side(0.0)
    , Test_Yaw(0.0)
    , Tuning_X(0.0)
    , Tuning_Side(0.0)
    , Tuning_Yaw(0.0)
    , Balance_Value_0(0.0)
    , Balance_Value_1(0.0)
    , Balance_Value_2(0.0)
    , Balance_Value_3(0.0)
    , Balance_Pitch_GP(0.0)
    , Balance_Pitch_GI(0.0)
    , Balance_Pitch_GD(0.0)
    , Balance_Pitch_ELIMIT(0.0)
    , Balance_Pitch_OLIMIT(0.0)
    , Balance_Pitch_Neg_Target(0.0)
    , Balance_Pitch_Pos_Target(0.0)
    , Balance_Roll_GP(0.0)
    , Balance_Roll_GI(0.0)
    , Balance_Roll_GD(0.0)
    , Balance_Roll_ELIMIT(0.0)
    , Balance_Roll_OLIMIT(0.0)
    , Balance_Roll_Neg_Target(0.0)
    , Balance_Roll_Pos_Target(0.0)
    , Balance_Angle_Pitch_GP(0.0)
    , Balance_Angle_Pitch_GI(0.0)
    , Balance_Angle_Pitch_GD(0.0)
    , Balance_Angle_Pitch_ELIMIT(0.0)
    , Balance_Angle_Pitch_OLIMIT(0.0)
    , Balance_Angle_Pitch_Neg_Target(0.0)
    , Balance_Angle_Pitch_Pos_Target(0.0)
    , Balance_Pitch_Flag(false)
    , Balance_Angle_Pitch_Flag(false)
    , Balance_Roll_Flag(false)
    , Balance_Time_Flag(0.0)  {
  (void)_alloc;
    }



   typedef uint8_t _IK_Flag_type;
  _IK_Flag_type IK_Flag;

   typedef double _Entire_Time_type;
  _Entire_Time_type Entire_Time;

   typedef double _Frequency_type;
  _Frequency_type Frequency;

   typedef double _Double_Ratio_type;
  _Double_Ratio_type Double_Ratio;

   typedef double _Single_Ratio_type;
  _Single_Ratio_type Single_Ratio;

   typedef double _Default_X_Right_type;
  _Default_X_Right_type Default_X_Right;

   typedef double _Default_X_Left_type;
  _Default_X_Left_type Default_X_Left;

   typedef double _Default_Y_Right_type;
  _Default_Y_Right_type Default_Y_Right;

   typedef double _Default_Y_Left_type;
  _Default_Y_Left_type Default_Y_Left;

   typedef double _Default_Z_Right_type;
  _Default_Z_Right_type Default_Z_Right;

   typedef double _Default_Z_Left_type;
  _Default_Z_Left_type Default_Z_Left;

   typedef double _Offset_10_Motor_type;
  _Offset_10_Motor_type Offset_10_Motor;

   typedef double _Offset_11_Motor_type;
  _Offset_11_Motor_type Offset_11_Motor;

   typedef double _Offset_12_Motor_type;
  _Offset_12_Motor_type Offset_12_Motor;

   typedef double _Offset_13_Motor_type;
  _Offset_13_Motor_type Offset_13_Motor;

   typedef double _Offset_14_Motor_type;
  _Offset_14_Motor_type Offset_14_Motor;

   typedef double _Offset_15_Motor_type;
  _Offset_15_Motor_type Offset_15_Motor;

   typedef double _Offset_16_Motor_type;
  _Offset_16_Motor_type Offset_16_Motor;

   typedef double _Offset_17_Motor_type;
  _Offset_17_Motor_type Offset_17_Motor;

   typedef double _Offset_18_Motor_type;
  _Offset_18_Motor_type Offset_18_Motor;

   typedef double _Offset_19_Motor_type;
  _Offset_19_Motor_type Offset_19_Motor;

   typedef double _Offset_20_Motor_type;
  _Offset_20_Motor_type Offset_20_Motor;

   typedef double _Offset_21_Motor_type;
  _Offset_21_Motor_type Offset_21_Motor;

   typedef double _Swing_Right_Leg_type;
  _Swing_Right_Leg_type Swing_Right_Leg;

   typedef double _Swing_Left_Leg_type;
  _Swing_Left_Leg_type Swing_Left_Leg;

   typedef double _Swing_Right_Shoulder_type;
  _Swing_Right_Shoulder_type Swing_Right_Shoulder;

   typedef double _Swing_Left_Shoulder_type;
  _Swing_Left_Shoulder_type Swing_Left_Shoulder;

   typedef double _Rise_Right_Leg_type;
  _Rise_Right_Leg_type Rise_Right_Leg;

   typedef double _Rise_Left_Leg_type;
  _Rise_Left_Leg_type Rise_Left_Leg;

   typedef double _Start_Entire_Time_type;
  _Start_Entire_Time_type Start_Entire_Time;

   typedef double _Start_Swing_type;
  _Start_Swing_type Start_Swing;

   typedef double _Start_Rise_type;
  _Start_Rise_type Start_Rise;

   typedef double _End_Entire_Time_type;
  _End_Entire_Time_type End_Entire_Time;

   typedef double _End_Swing_type;
  _End_Swing_type End_Swing;

   typedef double _End_Rise_type;
  _End_Rise_type End_Rise;

   typedef double _Test_X_type;
  _Test_X_type Test_X;

   typedef double _Test_Side_type;
  _Test_Side_type Test_Side;

   typedef double _Test_Yaw_type;
  _Test_Yaw_type Test_Yaw;

   typedef double _Tuning_X_type;
  _Tuning_X_type Tuning_X;

   typedef double _Tuning_Side_type;
  _Tuning_Side_type Tuning_Side;

   typedef double _Tuning_Yaw_type;
  _Tuning_Yaw_type Tuning_Yaw;

   typedef double _Balance_Value_0_type;
  _Balance_Value_0_type Balance_Value_0;

   typedef double _Balance_Value_1_type;
  _Balance_Value_1_type Balance_Value_1;

   typedef double _Balance_Value_2_type;
  _Balance_Value_2_type Balance_Value_2;

   typedef double _Balance_Value_3_type;
  _Balance_Value_3_type Balance_Value_3;

   typedef double _Balance_Pitch_GP_type;
  _Balance_Pitch_GP_type Balance_Pitch_GP;

   typedef double _Balance_Pitch_GI_type;
  _Balance_Pitch_GI_type Balance_Pitch_GI;

   typedef double _Balance_Pitch_GD_type;
  _Balance_Pitch_GD_type Balance_Pitch_GD;

   typedef double _Balance_Pitch_ELIMIT_type;
  _Balance_Pitch_ELIMIT_type Balance_Pitch_ELIMIT;

   typedef double _Balance_Pitch_OLIMIT_type;
  _Balance_Pitch_OLIMIT_type Balance_Pitch_OLIMIT;

   typedef double _Balance_Pitch_Neg_Target_type;
  _Balance_Pitch_Neg_Target_type Balance_Pitch_Neg_Target;

   typedef double _Balance_Pitch_Pos_Target_type;
  _Balance_Pitch_Pos_Target_type Balance_Pitch_Pos_Target;

   typedef double _Balance_Roll_GP_type;
  _Balance_Roll_GP_type Balance_Roll_GP;

   typedef double _Balance_Roll_GI_type;
  _Balance_Roll_GI_type Balance_Roll_GI;

   typedef double _Balance_Roll_GD_type;
  _Balance_Roll_GD_type Balance_Roll_GD;

   typedef double _Balance_Roll_ELIMIT_type;
  _Balance_Roll_ELIMIT_type Balance_Roll_ELIMIT;

   typedef double _Balance_Roll_OLIMIT_type;
  _Balance_Roll_OLIMIT_type Balance_Roll_OLIMIT;

   typedef double _Balance_Roll_Neg_Target_type;
  _Balance_Roll_Neg_Target_type Balance_Roll_Neg_Target;

   typedef double _Balance_Roll_Pos_Target_type;
  _Balance_Roll_Pos_Target_type Balance_Roll_Pos_Target;

   typedef double _Balance_Angle_Pitch_GP_type;
  _Balance_Angle_Pitch_GP_type Balance_Angle_Pitch_GP;

   typedef double _Balance_Angle_Pitch_GI_type;
  _Balance_Angle_Pitch_GI_type Balance_Angle_Pitch_GI;

   typedef double _Balance_Angle_Pitch_GD_type;
  _Balance_Angle_Pitch_GD_type Balance_Angle_Pitch_GD;

   typedef double _Balance_Angle_Pitch_ELIMIT_type;
  _Balance_Angle_Pitch_ELIMIT_type Balance_Angle_Pitch_ELIMIT;

   typedef double _Balance_Angle_Pitch_OLIMIT_type;
  _Balance_Angle_Pitch_OLIMIT_type Balance_Angle_Pitch_OLIMIT;

   typedef double _Balance_Angle_Pitch_Neg_Target_type;
  _Balance_Angle_Pitch_Neg_Target_type Balance_Angle_Pitch_Neg_Target;

   typedef double _Balance_Angle_Pitch_Pos_Target_type;
  _Balance_Angle_Pitch_Pos_Target_type Balance_Angle_Pitch_Pos_Target;

   typedef uint8_t _Balance_Pitch_Flag_type;
  _Balance_Pitch_Flag_type Balance_Pitch_Flag;

   typedef uint8_t _Balance_Angle_Pitch_Flag_type;
  _Balance_Angle_Pitch_Flag_type Balance_Angle_Pitch_Flag;

   typedef uint8_t _Balance_Roll_Flag_type;
  _Balance_Roll_Flag_type Balance_Roll_Flag;

   typedef double _Balance_Time_Flag_type;
  _Balance_Time_Flag_type Balance_Time_Flag;





  typedef boost::shared_ptr< ::msg_generate::eom_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::msg_generate::eom_msg_<ContainerAllocator> const> ConstPtr;

}; // struct eom_msg_

typedef ::msg_generate::eom_msg_<std::allocator<void> > eom_msg;

typedef boost::shared_ptr< ::msg_generate::eom_msg > eom_msgPtr;
typedef boost::shared_ptr< ::msg_generate::eom_msg const> eom_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::msg_generate::eom_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::msg_generate::eom_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::msg_generate::eom_msg_<ContainerAllocator1> & lhs, const ::msg_generate::eom_msg_<ContainerAllocator2> & rhs)
{
  return lhs.IK_Flag == rhs.IK_Flag &&
    lhs.Entire_Time == rhs.Entire_Time &&
    lhs.Frequency == rhs.Frequency &&
    lhs.Double_Ratio == rhs.Double_Ratio &&
    lhs.Single_Ratio == rhs.Single_Ratio &&
    lhs.Default_X_Right == rhs.Default_X_Right &&
    lhs.Default_X_Left == rhs.Default_X_Left &&
    lhs.Default_Y_Right == rhs.Default_Y_Right &&
    lhs.Default_Y_Left == rhs.Default_Y_Left &&
    lhs.Default_Z_Right == rhs.Default_Z_Right &&
    lhs.Default_Z_Left == rhs.Default_Z_Left &&
    lhs.Offset_10_Motor == rhs.Offset_10_Motor &&
    lhs.Offset_11_Motor == rhs.Offset_11_Motor &&
    lhs.Offset_12_Motor == rhs.Offset_12_Motor &&
    lhs.Offset_13_Motor == rhs.Offset_13_Motor &&
    lhs.Offset_14_Motor == rhs.Offset_14_Motor &&
    lhs.Offset_15_Motor == rhs.Offset_15_Motor &&
    lhs.Offset_16_Motor == rhs.Offset_16_Motor &&
    lhs.Offset_17_Motor == rhs.Offset_17_Motor &&
    lhs.Offset_18_Motor == rhs.Offset_18_Motor &&
    lhs.Offset_19_Motor == rhs.Offset_19_Motor &&
    lhs.Offset_20_Motor == rhs.Offset_20_Motor &&
    lhs.Offset_21_Motor == rhs.Offset_21_Motor &&
    lhs.Swing_Right_Leg == rhs.Swing_Right_Leg &&
    lhs.Swing_Left_Leg == rhs.Swing_Left_Leg &&
    lhs.Swing_Right_Shoulder == rhs.Swing_Right_Shoulder &&
    lhs.Swing_Left_Shoulder == rhs.Swing_Left_Shoulder &&
    lhs.Rise_Right_Leg == rhs.Rise_Right_Leg &&
    lhs.Rise_Left_Leg == rhs.Rise_Left_Leg &&
    lhs.Start_Entire_Time == rhs.Start_Entire_Time &&
    lhs.Start_Swing == rhs.Start_Swing &&
    lhs.Start_Rise == rhs.Start_Rise &&
    lhs.End_Entire_Time == rhs.End_Entire_Time &&
    lhs.End_Swing == rhs.End_Swing &&
    lhs.End_Rise == rhs.End_Rise &&
    lhs.Test_X == rhs.Test_X &&
    lhs.Test_Side == rhs.Test_Side &&
    lhs.Test_Yaw == rhs.Test_Yaw &&
    lhs.Tuning_X == rhs.Tuning_X &&
    lhs.Tuning_Side == rhs.Tuning_Side &&
    lhs.Tuning_Yaw == rhs.Tuning_Yaw &&
    lhs.Balance_Value_0 == rhs.Balance_Value_0 &&
    lhs.Balance_Value_1 == rhs.Balance_Value_1 &&
    lhs.Balance_Value_2 == rhs.Balance_Value_2 &&
    lhs.Balance_Value_3 == rhs.Balance_Value_3 &&
    lhs.Balance_Pitch_GP == rhs.Balance_Pitch_GP &&
    lhs.Balance_Pitch_GI == rhs.Balance_Pitch_GI &&
    lhs.Balance_Pitch_GD == rhs.Balance_Pitch_GD &&
    lhs.Balance_Pitch_ELIMIT == rhs.Balance_Pitch_ELIMIT &&
    lhs.Balance_Pitch_OLIMIT == rhs.Balance_Pitch_OLIMIT &&
    lhs.Balance_Pitch_Neg_Target == rhs.Balance_Pitch_Neg_Target &&
    lhs.Balance_Pitch_Pos_Target == rhs.Balance_Pitch_Pos_Target &&
    lhs.Balance_Roll_GP == rhs.Balance_Roll_GP &&
    lhs.Balance_Roll_GI == rhs.Balance_Roll_GI &&
    lhs.Balance_Roll_GD == rhs.Balance_Roll_GD &&
    lhs.Balance_Roll_ELIMIT == rhs.Balance_Roll_ELIMIT &&
    lhs.Balance_Roll_OLIMIT == rhs.Balance_Roll_OLIMIT &&
    lhs.Balance_Roll_Neg_Target == rhs.Balance_Roll_Neg_Target &&
    lhs.Balance_Roll_Pos_Target == rhs.Balance_Roll_Pos_Target &&
    lhs.Balance_Angle_Pitch_GP == rhs.Balance_Angle_Pitch_GP &&
    lhs.Balance_Angle_Pitch_GI == rhs.Balance_Angle_Pitch_GI &&
    lhs.Balance_Angle_Pitch_GD == rhs.Balance_Angle_Pitch_GD &&
    lhs.Balance_Angle_Pitch_ELIMIT == rhs.Balance_Angle_Pitch_ELIMIT &&
    lhs.Balance_Angle_Pitch_OLIMIT == rhs.Balance_Angle_Pitch_OLIMIT &&
    lhs.Balance_Angle_Pitch_Neg_Target == rhs.Balance_Angle_Pitch_Neg_Target &&
    lhs.Balance_Angle_Pitch_Pos_Target == rhs.Balance_Angle_Pitch_Pos_Target &&
    lhs.Balance_Pitch_Flag == rhs.Balance_Pitch_Flag &&
    lhs.Balance_Angle_Pitch_Flag == rhs.Balance_Angle_Pitch_Flag &&
    lhs.Balance_Roll_Flag == rhs.Balance_Roll_Flag &&
    lhs.Balance_Time_Flag == rhs.Balance_Time_Flag;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::msg_generate::eom_msg_<ContainerAllocator1> & lhs, const ::msg_generate::eom_msg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace msg_generate

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::msg_generate::eom_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::msg_generate::eom_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_generate::eom_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::msg_generate::eom_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_generate::eom_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::msg_generate::eom_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::msg_generate::eom_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2bab63df50bb1f7ece05fa6985761519";
  }

  static const char* value(const ::msg_generate::eom_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2bab63df50bb1f7eULL;
  static const uint64_t static_value2 = 0xce05fa6985761519ULL;
};

template<class ContainerAllocator>
struct DataType< ::msg_generate::eom_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "msg_generate/eom_msg";
  }

  static const char* value(const ::msg_generate::eom_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::msg_generate::eom_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool IK_Flag\n"
"float64 Entire_Time\n"
"float64 Frequency\n"
"float64 Double_Ratio\n"
"float64 Single_Ratio\n"
"float64 Default_X_Right\n"
"float64 Default_X_Left\n"
"float64 Default_Y_Right\n"
"float64 Default_Y_Left\n"
"float64 Default_Z_Right\n"
"float64 Default_Z_Left\n"
"float64 Offset_10_Motor\n"
"float64 Offset_11_Motor\n"
"float64 Offset_12_Motor\n"
"float64 Offset_13_Motor\n"
"float64 Offset_14_Motor\n"
"float64 Offset_15_Motor\n"
"float64 Offset_16_Motor\n"
"float64 Offset_17_Motor\n"
"float64 Offset_18_Motor\n"
"float64 Offset_19_Motor\n"
"float64 Offset_20_Motor\n"
"float64 Offset_21_Motor\n"
"float64 Swing_Right_Leg\n"
"float64 Swing_Left_Leg\n"
"float64 Swing_Right_Shoulder\n"
"float64 Swing_Left_Shoulder\n"
"float64 Rise_Right_Leg\n"
"float64 Rise_Left_Leg\n"
"float64 Start_Entire_Time\n"
"float64 Start_Swing\n"
"float64 Start_Rise\n"
"float64 End_Entire_Time\n"
"float64 End_Swing\n"
"float64 End_Rise\n"
"float64 Test_X\n"
"float64 Test_Side\n"
"float64 Test_Yaw\n"
"float64 Tuning_X\n"
"float64 Tuning_Side\n"
"float64 Tuning_Yaw\n"
"float64 Balance_Value_0\n"
"float64 Balance_Value_1\n"
"float64 Balance_Value_2\n"
"float64 Balance_Value_3\n"
"float64 Balance_Pitch_GP\n"
"float64 Balance_Pitch_GI\n"
"float64 Balance_Pitch_GD\n"
"float64 Balance_Pitch_ELIMIT\n"
"float64 Balance_Pitch_OLIMIT\n"
"float64 Balance_Pitch_Neg_Target\n"
"float64 Balance_Pitch_Pos_Target\n"
"float64 Balance_Roll_GP\n"
"float64 Balance_Roll_GI\n"
"float64 Balance_Roll_GD\n"
"float64 Balance_Roll_ELIMIT\n"
"float64 Balance_Roll_OLIMIT\n"
"float64 Balance_Roll_Neg_Target\n"
"float64 Balance_Roll_Pos_Target\n"
"float64 Balance_Angle_Pitch_GP\n"
"float64 Balance_Angle_Pitch_GI\n"
"float64 Balance_Angle_Pitch_GD\n"
"float64 Balance_Angle_Pitch_ELIMIT\n"
"float64 Balance_Angle_Pitch_OLIMIT\n"
"float64 Balance_Angle_Pitch_Neg_Target\n"
"float64 Balance_Angle_Pitch_Pos_Target\n"
"bool Balance_Pitch_Flag\n"
"bool Balance_Angle_Pitch_Flag\n"
"bool Balance_Roll_Flag\n"
"float64 Balance_Time_Flag\n"
"\n"
;
  }

  static const char* value(const ::msg_generate::eom_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::msg_generate::eom_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.IK_Flag);
      stream.next(m.Entire_Time);
      stream.next(m.Frequency);
      stream.next(m.Double_Ratio);
      stream.next(m.Single_Ratio);
      stream.next(m.Default_X_Right);
      stream.next(m.Default_X_Left);
      stream.next(m.Default_Y_Right);
      stream.next(m.Default_Y_Left);
      stream.next(m.Default_Z_Right);
      stream.next(m.Default_Z_Left);
      stream.next(m.Offset_10_Motor);
      stream.next(m.Offset_11_Motor);
      stream.next(m.Offset_12_Motor);
      stream.next(m.Offset_13_Motor);
      stream.next(m.Offset_14_Motor);
      stream.next(m.Offset_15_Motor);
      stream.next(m.Offset_16_Motor);
      stream.next(m.Offset_17_Motor);
      stream.next(m.Offset_18_Motor);
      stream.next(m.Offset_19_Motor);
      stream.next(m.Offset_20_Motor);
      stream.next(m.Offset_21_Motor);
      stream.next(m.Swing_Right_Leg);
      stream.next(m.Swing_Left_Leg);
      stream.next(m.Swing_Right_Shoulder);
      stream.next(m.Swing_Left_Shoulder);
      stream.next(m.Rise_Right_Leg);
      stream.next(m.Rise_Left_Leg);
      stream.next(m.Start_Entire_Time);
      stream.next(m.Start_Swing);
      stream.next(m.Start_Rise);
      stream.next(m.End_Entire_Time);
      stream.next(m.End_Swing);
      stream.next(m.End_Rise);
      stream.next(m.Test_X);
      stream.next(m.Test_Side);
      stream.next(m.Test_Yaw);
      stream.next(m.Tuning_X);
      stream.next(m.Tuning_Side);
      stream.next(m.Tuning_Yaw);
      stream.next(m.Balance_Value_0);
      stream.next(m.Balance_Value_1);
      stream.next(m.Balance_Value_2);
      stream.next(m.Balance_Value_3);
      stream.next(m.Balance_Pitch_GP);
      stream.next(m.Balance_Pitch_GI);
      stream.next(m.Balance_Pitch_GD);
      stream.next(m.Balance_Pitch_ELIMIT);
      stream.next(m.Balance_Pitch_OLIMIT);
      stream.next(m.Balance_Pitch_Neg_Target);
      stream.next(m.Balance_Pitch_Pos_Target);
      stream.next(m.Balance_Roll_GP);
      stream.next(m.Balance_Roll_GI);
      stream.next(m.Balance_Roll_GD);
      stream.next(m.Balance_Roll_ELIMIT);
      stream.next(m.Balance_Roll_OLIMIT);
      stream.next(m.Balance_Roll_Neg_Target);
      stream.next(m.Balance_Roll_Pos_Target);
      stream.next(m.Balance_Angle_Pitch_GP);
      stream.next(m.Balance_Angle_Pitch_GI);
      stream.next(m.Balance_Angle_Pitch_GD);
      stream.next(m.Balance_Angle_Pitch_ELIMIT);
      stream.next(m.Balance_Angle_Pitch_OLIMIT);
      stream.next(m.Balance_Angle_Pitch_Neg_Target);
      stream.next(m.Balance_Angle_Pitch_Pos_Target);
      stream.next(m.Balance_Pitch_Flag);
      stream.next(m.Balance_Angle_Pitch_Flag);
      stream.next(m.Balance_Roll_Flag);
      stream.next(m.Balance_Time_Flag);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct eom_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::msg_generate::eom_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::msg_generate::eom_msg_<ContainerAllocator>& v)
  {
    s << indent << "IK_Flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.IK_Flag);
    s << indent << "Entire_Time: ";
    Printer<double>::stream(s, indent + "  ", v.Entire_Time);
    s << indent << "Frequency: ";
    Printer<double>::stream(s, indent + "  ", v.Frequency);
    s << indent << "Double_Ratio: ";
    Printer<double>::stream(s, indent + "  ", v.Double_Ratio);
    s << indent << "Single_Ratio: ";
    Printer<double>::stream(s, indent + "  ", v.Single_Ratio);
    s << indent << "Default_X_Right: ";
    Printer<double>::stream(s, indent + "  ", v.Default_X_Right);
    s << indent << "Default_X_Left: ";
    Printer<double>::stream(s, indent + "  ", v.Default_X_Left);
    s << indent << "Default_Y_Right: ";
    Printer<double>::stream(s, indent + "  ", v.Default_Y_Right);
    s << indent << "Default_Y_Left: ";
    Printer<double>::stream(s, indent + "  ", v.Default_Y_Left);
    s << indent << "Default_Z_Right: ";
    Printer<double>::stream(s, indent + "  ", v.Default_Z_Right);
    s << indent << "Default_Z_Left: ";
    Printer<double>::stream(s, indent + "  ", v.Default_Z_Left);
    s << indent << "Offset_10_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_10_Motor);
    s << indent << "Offset_11_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_11_Motor);
    s << indent << "Offset_12_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_12_Motor);
    s << indent << "Offset_13_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_13_Motor);
    s << indent << "Offset_14_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_14_Motor);
    s << indent << "Offset_15_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_15_Motor);
    s << indent << "Offset_16_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_16_Motor);
    s << indent << "Offset_17_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_17_Motor);
    s << indent << "Offset_18_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_18_Motor);
    s << indent << "Offset_19_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_19_Motor);
    s << indent << "Offset_20_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_20_Motor);
    s << indent << "Offset_21_Motor: ";
    Printer<double>::stream(s, indent + "  ", v.Offset_21_Motor);
    s << indent << "Swing_Right_Leg: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_Right_Leg);
    s << indent << "Swing_Left_Leg: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_Left_Leg);
    s << indent << "Swing_Right_Shoulder: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_Right_Shoulder);
    s << indent << "Swing_Left_Shoulder: ";
    Printer<double>::stream(s, indent + "  ", v.Swing_Left_Shoulder);
    s << indent << "Rise_Right_Leg: ";
    Printer<double>::stream(s, indent + "  ", v.Rise_Right_Leg);
    s << indent << "Rise_Left_Leg: ";
    Printer<double>::stream(s, indent + "  ", v.Rise_Left_Leg);
    s << indent << "Start_Entire_Time: ";
    Printer<double>::stream(s, indent + "  ", v.Start_Entire_Time);
    s << indent << "Start_Swing: ";
    Printer<double>::stream(s, indent + "  ", v.Start_Swing);
    s << indent << "Start_Rise: ";
    Printer<double>::stream(s, indent + "  ", v.Start_Rise);
    s << indent << "End_Entire_Time: ";
    Printer<double>::stream(s, indent + "  ", v.End_Entire_Time);
    s << indent << "End_Swing: ";
    Printer<double>::stream(s, indent + "  ", v.End_Swing);
    s << indent << "End_Rise: ";
    Printer<double>::stream(s, indent + "  ", v.End_Rise);
    s << indent << "Test_X: ";
    Printer<double>::stream(s, indent + "  ", v.Test_X);
    s << indent << "Test_Side: ";
    Printer<double>::stream(s, indent + "  ", v.Test_Side);
    s << indent << "Test_Yaw: ";
    Printer<double>::stream(s, indent + "  ", v.Test_Yaw);
    s << indent << "Tuning_X: ";
    Printer<double>::stream(s, indent + "  ", v.Tuning_X);
    s << indent << "Tuning_Side: ";
    Printer<double>::stream(s, indent + "  ", v.Tuning_Side);
    s << indent << "Tuning_Yaw: ";
    Printer<double>::stream(s, indent + "  ", v.Tuning_Yaw);
    s << indent << "Balance_Value_0: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Value_0);
    s << indent << "Balance_Value_1: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Value_1);
    s << indent << "Balance_Value_2: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Value_2);
    s << indent << "Balance_Value_3: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Value_3);
    s << indent << "Balance_Pitch_GP: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_GP);
    s << indent << "Balance_Pitch_GI: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_GI);
    s << indent << "Balance_Pitch_GD: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_GD);
    s << indent << "Balance_Pitch_ELIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_ELIMIT);
    s << indent << "Balance_Pitch_OLIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_OLIMIT);
    s << indent << "Balance_Pitch_Neg_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_Neg_Target);
    s << indent << "Balance_Pitch_Pos_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Pitch_Pos_Target);
    s << indent << "Balance_Roll_GP: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_GP);
    s << indent << "Balance_Roll_GI: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_GI);
    s << indent << "Balance_Roll_GD: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_GD);
    s << indent << "Balance_Roll_ELIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_ELIMIT);
    s << indent << "Balance_Roll_OLIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_OLIMIT);
    s << indent << "Balance_Roll_Neg_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_Neg_Target);
    s << indent << "Balance_Roll_Pos_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Roll_Pos_Target);
    s << indent << "Balance_Angle_Pitch_GP: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_GP);
    s << indent << "Balance_Angle_Pitch_GI: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_GI);
    s << indent << "Balance_Angle_Pitch_GD: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_GD);
    s << indent << "Balance_Angle_Pitch_ELIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_ELIMIT);
    s << indent << "Balance_Angle_Pitch_OLIMIT: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_OLIMIT);
    s << indent << "Balance_Angle_Pitch_Neg_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_Neg_Target);
    s << indent << "Balance_Angle_Pitch_Pos_Target: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Angle_Pitch_Pos_Target);
    s << indent << "Balance_Pitch_Flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Balance_Pitch_Flag);
    s << indent << "Balance_Angle_Pitch_Flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Balance_Angle_Pitch_Flag);
    s << indent << "Balance_Roll_Flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Balance_Roll_Flag);
    s << indent << "Balance_Time_Flag: ";
    Printer<double>::stream(s, indent + "  ", v.Balance_Time_Flag);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MSG_GENERATE_MESSAGE_EOM_MSG_H
